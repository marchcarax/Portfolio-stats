"""
Inputs (Features):
For each strategy, the inputs will consist of the signals generated:
Turtle system: EL (Entry Long) and ExL (Exit Long)
Rolling Sharpe: sell and buy
RSI: RSI_buy and RSI_sell
Fibonacci: buy_signal and sell_signal
Target Variable:
The target variable will indicate the action to take (buy or sell) based on the combined signals of the strategies.
Steps to Prepare Data:
Feature Engineering:

Collect the signals generated by each strategy for each observation in the dataset.
Define Target Variable:

Generate the target variable based on the combined signals. For instance:
If a majority of strategies suggest buying, set the target variable as 'buy'.
If a majority of strategies suggest selling, set the target variable as 'sell'.
Train-Validation Split:

Split the dataset into training and validation sets.
Train XGBoost Classifier:

Use XGBoost to build a classifier that learns the optimal combination of strategy signals to predict the target variable.
Here's a conceptual representation of the data structure:

EL	ExL	sell	buy	RSI_buy	RSI_sell	buy_signal	sell_signal	Target
0	1	0	1	0	1	1	0	'buy'
1	0	1	0	1	0	0	1	'sell'
...	...	...	...	...	...	...	...	...
Each row represents a data point (observation) with the strategy signals (features) and the target variable indicating the action to take.

I've provided a simplified structure here, but creating this dataset involves merging the signals from different strategies, defining the target variable based on the combined signals, and then training an XGBoost classifier using this prepared dataset.
"""

import pandas as pd
import numpy as np
from xgboost import XGBClassifier

def ensemble_model(df, capital, add_capital, start_date, buy_level, sell_level, rsi_buy_level, rsi_sell_level):
    """Computes complex strategy for combining signals from 4 strategies"""

    # Calculate rolling Sharpe ratio
    df["sharpe"] = rolling_sharpe(df["ret"], n=20)

    # Calculate RSI
    df["RSI"] = pd.Series(df["close"].pct_change().ewm(span=14).mean(), name="RSI")

    # Calculate signals from all 4 strategies
    df["strategy_1_signal"] = compute_strat_8(df.copy(), capital, add_capital)["buy_signal"]
    df["strategy_2_signal"] = compute_strat_9(df.copy(), capital, add_capital, w_buy=buy_level, w_sell=sell_level)["buy_signal"]
    df["strategy_3_signal"] = compute_strat_4(df.copy(), capital, add_capital, start_date, buy_level, sell_level)["buy"]
    df["strategy_4_signal"] = (df["RSI"] < rsi_buy_level).astype(int) - (df["RSI"] > rsi_sell_level).astype(int)

    # Extract features from signals
    df["strategy_1_norm"] = (df["strategy_1_signal"] - df["strategy_1_signal"].mean()) / df["strategy_1_signal"].std()
    df["strategy_2_norm"] = (df["strategy_2_signal"] - df["strategy_2_signal"].mean()) / df["strategy_2_signal"].std()
    df["strategy_3_norm"] = (df["strategy_3_signal"] - df["strategy_3_signal"].mean()) / df["strategy_3_signal"].std()
    df["strategy_4_norm"] = (df["strategy_4_signal"] - df["strategy_4_signal"].mean()) / df["strategy_4_signal"].std()

    # Combine features into a single DataFrame
    df_features = df[[
        "strategy_1_norm", "strategy_2_norm", "strategy_3_norm", "strategy_4_norm", "ret"
    ]]

    # Train XGBoost model
    xgb_model = XGBClassifier()
    xgb_model.fit(df_features, df["ret"])

    # Predict buy/sell signals using XGBoost model
    df["combined_signal"] = xgb_model.predict(df_features)

    return df
